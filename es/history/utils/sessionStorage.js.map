{"version":3,"sources":["../../../src/history/utils/sessionStorage.js"],"names":["supportsSession","supportsHistory","toEntries","saveHistory","out","index","entries","map","e","location","url","state","key","set","restoreHistory","api","history","get","initializeHistory","format","clear","sessionClear","historyClear","v","sessionSet","historySet","sessionGet","historyGet","pushState","window","id","sessionId","replaceState","getHistoryState","_id","PREFIX","createSessionId","sessionStorage","setItem","val","JSON","stringify","json","getItem","parse","error","process","env","NODE_ENV","toString","substr","Math","random","pathname","search","hash","n","ents","slice"],"mappings":"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","sourcesContent":["// @flow\n/* eslint-env browser */\nimport { supportsSession, supportsHistory } from './index'\nimport { toEntries } from '../../utils'\n\n// API:\n\n// Below is the facade around both `sessionStorage` and our \"history as storage\" fallback.\n//\n// - `saveHistory` is  called every time the history entries or index changes\n// - `restoreHistory` is called on startup obviously\n\n// Essentially the idea is that if there is no `sessionStorage`, we maintain the entire\n// storage object on EACH AND EVERY history entry's `state`. I.e. `history.state` on\n// every page will have the `index` and `entries` array. That way when browsers disable\n// cookies/sessionStorage, we can still grab the data we need off off of history state :)\n//\n// It's a bit crazy, but it works very well, and there's plenty of space allowed for storing\n// things there to get a lot of mileage out of it. We store the minimum amount of data necessary.\n//\n// Firefox has the lowest limit of 640kb PER ENTRY. IE has 1mb and chrome has at least 10mb:\n// https://stackoverflow.com/questions/6460377/html5-history-api-what-is-the-max-size-the-state-object-can-be\n\nexport const saveHistory = (\n  { index, entries }: { index: number },\n  out: void | Function,\n) => {\n  entries = entries.map((e) => [e.location.url, e.state, e.location.key]) // one entry has the url, a state object, and a 6 digit key\n  set({ index, entries, out })\n}\n\nexport const restoreHistory = (api) => {\n  const history = get() || initializeHistory()\n  return format(history, api)\n}\n\nexport const clear = () => (supportsSession() ? sessionClear() : historyClear())\n\nexport const set = (v) => (supportsSession() ? sessionSet(v) : historySet(v))\n\nexport const get = () => (supportsSession() ? sessionGet() : historyGet())\n\n// HISTORY FACADE:\n\nexport const pushState = (url: string) =>\n  window.history.pushState({ id: sessionId() }, null, url) // insure every entry has the sessionId (called by `BrowserHistory`)\n\nexport const replaceState = (url: string) =>\n  window.history.replaceState({ id: sessionId() }, null, url) // QA: won't the fallback overwrite the `id`? Yes, but the fallback doesn't use the `id` :)\n\nconst historyClear = () => window.history.replaceState({}, null)\n\nconst historySet = (history) => window.history.replaceState(history, null) // set on current entry\n\nconst historyGet = () => {\n  const state = getHistoryState()\n  return state.entries && state\n}\n\n// SESSION STORAGE FACADE:\n\n// We use `history.state.id` to pick which \"session\" from `sessionStorage` to use in\n// the case that multiple windows containing the app are open at the same time\nlet _id\n\nconst PREFIX = '@@rudy/'\n\nconst sessionId = () => (_id = _id || createSessionId())\n\nconst key = () => PREFIX + sessionId()\n\nconst sessionClear = () => window.sessionStorage.setItem(key(), '')\n\nconst sessionSet = (val) =>\n  window.sessionStorage.setItem(key(), JSON.stringify(val))\n\nconst sessionGet = () => {\n  try {\n    const json = window.sessionStorage.getItem(key())\n    return JSON.parse(json)\n  } catch (error) {} // ignore invalid JSON\n  return null\n}\n\nconst createSessionId = () => {\n  if (!supportsHistory() || !supportsSession()) return 'id' // both are needed for unique IDs to serve their purpose\n\n  const state = getHistoryState()\n\n  if (!state.id) {\n    if (process.env.NODE_ENV === 'test') {\n      state.id = '123456789'.toString(36).substr(2, 6)\n    } else {\n      state.id = Math.random()\n        .toString(36)\n        .substr(2, 6)\n    }\n    historySet(state)\n  }\n\n  return state.id\n}\n\n// HELPERS:\n\nconst initializeHistory = () => {\n  const { pathname, search, hash } = window.location\n  const url = pathname + search + hash\n  return { n: 1, index: 0, entries: [url] } // default history on first load\n}\n\n// We must remove entries after the index in case the user opened a link to\n// another site in the middle of the entries stack and then returned via the\n// back button, in which case the entries are gone for good, like a `push`.\n//\n// NOTE: if we did this on the first entry, we would break backing out of the\n// site and returning (entries would be unnecessarily removed). So this is only applied to\n// \"forwarding out.\" That leaves one hole: if you forward out from the first entry, you will\n// return and have problematic entries that should NOT be there. Then because of Rudy's\n// automatic back/next detection, which causes the history track to \"jump\" instead of \"push,\"\n// dispatching an action for the next entry would in fact make you leave the site instead\n// of push the new entry! To circumvent that, use Rudy's <Link /> component and it will\n// save the `out` flag (just before linking out) that insures this is addressed:\nconst format = (history, api) => {\n  const { entries, index, out } = history\n  const ents = index > 0 || out ? entries.slice(0, index + 1) : entries\n  return toEntries(api, ents, index)\n}\n\n// IE11 sometimes throws when accessing `history.state`:\n//\n// - https://github.com/ReactTraining/history/pull/289\n// - https://github.com/ReactTraining/history/pull/230#issuecomment-193555362\n//\n// The issue occurs:\n// A) when you refresh a page that is the only entry and never had state set on it,\n// which means it wouldn't have any state to remember in the first place\n//\n// B) in IE11 on load in iframes, which also won't need to remember state, as iframes\n// usually aren't for navigating to other sites (and back). This may just be issue A)\n//\n// ALSO NOTE: this would only matter when using our history state fallback, as we don't use\n// `history.state` with `sessionStorage`, with one exception: `state.id`. The `id` is used for\n// a single edge case: having multiple windows open (see \"Session Storage Facade\" above).\nconst getHistoryState = () => {\n  try {\n    return window.history.state || {}\n  } catch (e) {}\n  return {}\n}\n"],"file":"sessionStorage.js"}