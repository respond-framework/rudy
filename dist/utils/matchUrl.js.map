{"version":3,"sources":["../../src/utils/matchUrl.js"],"names":["loc","matchers","options","route","opts","pathname","search","h","hash","matchPath","path","match","keys","query","matchQuery","matchHash","values","params","reduce","_params","key","index","repeat","name","split","map","decodeURIComponent","undefined","formatParams","formatQuery","formatHash","matchedPath","partial","matcher","compilePath","re","exec","exact","parseSearch","matchFails","matchVal","Object","some","expected","val","type","RegExp","test","queries","parse","patternCache","cacheLimit","cacheCount","pattern","strict","cacheKey","cache","end","compiledPattern"],"mappings":"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","sourcesContent":["// @flow\nimport pathToRegexp from 'path-to-regexp'\nimport { urlToLocation } from './index'\nimport type { Route, Options } from '../flow-types'\n\nexport default (\n  loc: string | Location,\n  matchers: Matchers,\n  options?: Object = {},\n  route: Route,\n  opts: Options = {},\n) => {\n  const { pathname, search, hash: h } = urlToLocation(loc)\n\n  const { match, keys } = matchPath(pathname, matchers.path, options)\n  if (!match) return null\n\n  const query = matchQuery(search, matchers.query, route, opts)\n  if (!query) return null\n\n  const hash = matchHash(h, matchers.hash, route, opts)\n  if (hash === null) return null\n\n  const [path, ...values] = match\n  const params = keys.reduce((_params, key, index) => {\n    if (key.repeat) {\n      // Multi segment params come out as arrays of decoded segments\n      // If optional multi segment params are not provided, an empty array\n      _params[key.name] = values[index]\n        ? values[index].split('/').map(decodeURIComponent)\n        : []\n    } else {\n      _params[key.name] =\n        typeof values[index] === 'string'\n          ? decodeURIComponent(values[index])\n          : undefined\n    }\n    return _params\n  }, {})\n\n  const { formatParams, formatQuery, formatHash } = options\n\n  return {\n    params: formatParams ? formatParams(params, route, keys, opts) : params,\n    query: formatQuery ? formatQuery(query, route, opts) : query,\n    hash: formatHash ? formatHash(hash || '', route, opts) : hash || '',\n    matchedPath: matchers.path === '/' && path === '' ? '/' : path, // the matched portion of the URL/path\n    matchers,\n    partial: !!options.partial,\n  }\n\n  // const url = matchers.path === '/' && path === '' ? '/' : path // the matched portion of the path\n\n  // return {\n  //   path: matchers.path,\n  //   url, // called `url` instead of `path` for compatibility with React Router\n  //   isExact: pathname === path,\n  //   params: fromPath ? fromPath(params, route, opts) : params,\n  //   query: fromSearch ? fromSearch(query, route, opts) : query,\n  //   hash: fromHash ? fromHash(hash || '', route, opts) : (hash || '')\n  // }\n}\n\nconst matchPath = (pathname, matcher, options = {}) => {\n  const { re, keys } = compilePath(matcher, options)\n  const match = re.exec(pathname)\n\n  if (!match || (options.exact && match[0] !== pathname)) return {}\n\n  return { match, keys }\n}\n\nexport const matchQuery = (\n  search: string,\n  matcher: ?Object,\n  route: Route,\n  opts: Options,\n): null | {} => {\n  const query: {} = search ? parseSearch(search, route, opts) : {}\n\n  if (!matcher) return query\n\n  const matchFails = (key) =>\n    !matchVal(query[key], matcher[key], key, route, opts)\n  if (Object.keys(matcher).some(matchFails)) return null\n\n  return query\n}\n\nexport const matchHash = (\n  hash: string = '',\n  expected: ?string,\n  route: Route,\n  opts: Options,\n): string | null => {\n  if (expected === undefined) return hash\n  return matchVal(hash, expected, 'hash', route, opts) ? hash : null\n}\n\nexport const matchVal = (\n  val: ?string,\n  // TODO: What flow-type is best for expected\n  // $FlowFixMe\n  expected,\n  key: string,\n  route: Route,\n  opts: Options,\n) => {\n  const type = typeof expected\n\n  if (type === 'boolean') {\n    if (expected === true) {\n      return val !== '' && val !== undefined\n    }\n\n    return val === undefined || val === ''\n  }\n  if (type === 'string') {\n    return expected === val\n  }\n  if (type === 'function') {\n    return key === 'hash'\n      ? // $FlowFixMe\n        expected(val, route, opts)\n      : // $FlowFixMe\n        expected(val, key, route, opts)\n  }\n  if (expected instanceof RegExp) {\n    return expected.test(val)\n  }\n\n  return true\n}\n\nconst parseSearch = (search: string, route: Route, opts: Options): Object => {\n  if (queries[search]) return queries[search]\n  const parse = route.parseSearch || opts.parseSearch\n  queries[search] = parse(search)\n  return queries[search]\n}\n\nconst queries: {} = {}\nconst patternCache: {} = {}\n\nconst cacheLimit = 10000\nlet cacheCount = 0\n\nconst compilePath = (\n  pattern: string,\n  options: CompileOptions = {},\n  // eslint-disable-next-line no-use-before-define\n): Compiled => {\n  const {\n    partial = false,\n    strict = false,\n  }: {\n    partial?: boolean,\n    strict?: boolean,\n  } = options\n\n  const cacheKey: string = `${partial ? 't' : 'f'}${strict ? 't' : 'f'}`\n  const cache: {} = patternCache[cacheKey] || (patternCache[cacheKey] = {})\n\n  if (cache[pattern]) return cache[pattern]\n\n  const keys: [] = []\n  const re = pathToRegexp(pattern, keys, { end: !partial, strict })\n  const compiledPattern = { re, keys }\n\n  if (cacheCount < cacheLimit) {\n    cache[pattern] = compiledPattern\n    cacheCount += 1\n  }\n  // TODO: Not sure the best way to construct this one\n  // $FlowFixMe\n  return compiledPattern\n}\n\ntype CompileOptions = {\n  partial?: boolean,\n  strict?: boolean,\n}\n\n// type MatchOptions = {\n//   partial?: boolean,\n//   strict?: boolean,\n//   path?: string,\n// }\n\ntype Compiled = {\n  re: RegExp,\n  keys: Array<{ name: string, repeat: Boolean, optional: Boolean }>,\n}\n\n// type Match = {\n//   path: string,\n//   url: string,\n//   isExact: boolean,\n//   params: Object,\n// }\n\ntype Matchers = {\n  path: string,\n  query?: Object,\n  hash?: string,\n}\n\ntype Location = {\n  pathname: string,\n  search: string,\n  hash: string,\n}\n"],"file":"matchUrl.js"}