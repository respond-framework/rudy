{"version":3,"sources":["../../src/history/BrowserHistory.js"],"names":["BrowserHistory","options","restore","restoreHistory","save","saveHistory","_setupPopHandling","dispatch","getLocation","_addPopListener","unlisten","_removePopListener","url","e","entries","index","location","handlePop","_popForced","window","pathname","search","hash","n","pendingPop","_didPopForward","_forceGo","reverted","revertPop","currentPop","jump","onPopState","onHashChange","history","go","Promise","resolve","action","awaitUrl","_awaitUrl","then","kind","currUrl","oldUrl","isPop","_replace","changedAction","oldFirstUrl","reverseN","lastIndex","length","reverseDeltaToIndex","indexUrl","slice","forEach","actOrUrl","name","ready","console","log","tryChange","History","tries","maxTries","queue","complete","rapidChangeWorkaround","push","setTimeout","process","env","NODE_ENV","Error","shift","again","com"],"mappings":"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","sourcesContent":["// @flow\n/* eslint-env browser */\nimport History from './History'\nimport { locationToUrl } from '../utils'\nimport {\n  addPopListener,\n  removePopListener,\n  isExtraneousPopEvent,\n  restoreHistory,\n  saveHistory,\n  pushState,\n  replaceState,\n} from './utils'\nimport type { Action, Dispatch } from '../flow-types'\n\n// 1) HISTORY RESTORATION:\n// * FROM SESSION_STORAGE (WITH A FALLBACK TO OUR \"HISTORY_STORAGE\" SOLUTION)\n\n// The `id` below is very important, as it's used to identify unique `sessionStorage` sessions lol.\n\n// Essentially, you can have multiple tabs open, or even in the same tab multiple sessions if you\n// enter another URL at the same site manually. Each need their history entries independently tracked.\n\n// So we:\n// - create an `id` for each when first encountered\n// - store it in `this.state.id`\n// - and prefix their `sessionStorage` key with it to uniquely identify the different histories :)\n\n// - then we restore the history using the id\n// - and for all subsequent history saving, we save to the correct storage with that `id`\n\n// NOTE: As far as the \"HISTORY_STORAGE\" fallback goes, please `sessionStorage.js`.\n// Essentially we save the entire sessionStorage in every entry of `window.history` :)\n\n// 2) POP HANDLING -- THE MOST IMPORTANT THING HERE:\n\n// A) REVERT POP: `forceGo(currentIndex - index)`\n// The first executed `forceGo` automatically undos the pop event, putting the browser history\n// back to where it was. Since the `jump` function takes relative numbers, we must calculate\n// that number by subtracting the current index from the next index\n\n// B) COMMIT POP: `forceGo(index - currentIndex)`\n// similarly the `commit` function performed in client code performs the reverse operation\n\n// EXAMPLE:\n// User presses back from index 5 to 4\n// revert: 5 - 4 === jump(1)\n// commit: 4 - 5 === jump(-1)\n// :)\n\n// WHY?\n// so client code can control when the URL actually changes, and possibly deny it\n\nexport default class BrowserHistory extends History {\n  _restore() {\n    this.options.restore = this.options.restore || restoreHistory\n    this.options.save = this.options.save || saveHistory\n\n    this._setupPopHandling()\n\n    return this.options.restore(this)\n  }\n\n  listen(dispatch: Dispatch, getLocation: Function) {\n    if (!this.dispatch) {\n      // we don't allow/need multiple listeners currently\n      super.listen(dispatch, getLocation)\n      this._addPopListener()\n    }\n\n    return () => this.unlisten()\n  }\n\n  unlisten() {\n    this._removePopListener()\n    super.unlisten()\n  }\n\n  _didPopForward(url: string) {\n    const e = this.entries[this.index + 1]\n    return e && e.location.url === url\n  }\n\n  _setupPopHandling() {\n    const handlePop = () => {\n      if (this._popForced) return (this._popForced = false)\n\n      const { pathname, search, hash } = window.location\n      const url = pathname + search + hash\n\n      let n\n\n      if (!this.pendingPop) {\n        n = this._didPopForward(url) ? 1 : -1\n        this.pendingPop = n\n      } else if (url === this.url) {\n        n = this.pendingPop * -1 // switch directions\n        return this._forceGo(n * -1)\n      } else {\n        n = this.pendingPop\n        return this._forceGo(n * -1)\n      }\n\n      let reverted = false\n\n      const revertPop = () => {\n        if (!reverted) this._forceGo(n * -1)\n        reverted = true\n      }\n\n      // revertPop will be called if route change blocked by `core/compose.js` or used as\n      // a flag by `this._jump` below to do nothing in the browser, since the user already\n      // did it via browser back/next buttons\n      this.currentPop = this.jump(n, false, n, null, true, revertPop) // `currentPop` used only by tests to await browser-initiated pops\n    }\n\n    const onPopState = (e) => !isExtraneousPopEvent(e) && handlePop() // ignore extraneous popstate events in WebKit\n    const onHashChange = handlePop\n\n    this._addPopListener = () => addPopListener(onPopState, onHashChange)\n    this._removePopListener = () => removePopListener(onPopState, onHashChange)\n  }\n\n  _forceGo(n: number): Promise<void> {\n    this._popForced = true\n    window.history.go(n) // revert\n    return Promise.resolve()\n  }\n\n  _push(action: Action, awaitUrl: string): Promise<any> {\n    const { url } = action.location\n\n    return this._awaitUrl(awaitUrl, '_push').then(() => pushState(url))\n  }\n\n  _replace(action: Action, awaitUrl: string, n?: number): Promise<any> {\n    const { url } = action.location\n\n    if (n) {\n      this._forceGo(n)\n\n      return this._awaitUrl(awaitUrl, '_replaceBackNext').then(() =>\n        replaceState(url),\n      )\n    }\n\n    if (this.location.kind === 'load') {\n      awaitUrl = locationToUrl(window.location) // special case: redirects on load have no previous URL\n    }\n\n    return this._awaitUrl(awaitUrl, '_replace').then(() => replaceState(url))\n  }\n\n  _jump(\n    action: Action,\n    currUrl: string,\n    oldUrl: string,\n    n: number,\n    isPop: boolean,\n  ): void | Promise<any> {\n    if (!n) {\n      // possibly the user mathematically calculated a jump of `0`\n      return this._replace(action, currUrl)\n    }\n\n    if (isPop) return // pop already handled by browser back/next buttons and real history state is already up to date\n\n    return this._awaitUrl(currUrl, 'jump prev')\n      .then(() => this._forceGo(n))\n      .then(() => this._awaitUrl(oldUrl, 'jump loc'))\n      .then(() => this._replace(action, oldUrl))\n  }\n\n  _set(action: Action, oldUrl: string, n: number): Promise<any> {\n    if (!n) {\n      return this._replace(action, oldUrl)\n    }\n\n    const { index, entries } = action.location\n    const changedAction = entries[index + n]\n\n    return this._awaitUrl(action, '_setN start')\n      .then(() => this._forceGo(n))\n      .then(() => this._awaitUrl(oldUrl, '_setN before replace'))\n      .then(() => this._replace(changedAction, oldUrl))\n      .then(() => this._forceGo(-n))\n      .then(() => this._awaitUrl(action, 'setN return'))\n  }\n\n  _reset(\n    action: Action,\n    oldUrl: string,\n    oldFirstUrl: string,\n    reverseN: number,\n  ): Promise<any> {\n    const { index, entries } = action.location\n    const lastIndex = entries.length - 1\n    const reverseDeltaToIndex = index - lastIndex\n    const indexUrl = entries[index].location.url\n\n    return this._awaitUrl(oldUrl, 'reset oldUrl')\n      .then(() => this._forceGo(reverseN))\n      .then(() => this._awaitUrl(oldFirstUrl, 'reset oldFirstUrl'))\n      .then(() => {\n        replaceState(entries[0].location.url) // we always insure resets have at least 2 entries, and the first can only operate via `replaceState`\n        entries.slice(1).forEach((e) => pushState(e.location.url)) // we have to push at least one entry to erase the old entries in the real browser history\n\n        if (reverseDeltaToIndex) {\n          return this._forceGo(reverseDeltaToIndex).then(() =>\n            this._awaitUrl(indexUrl, 'resetIndex _forceGo'),\n          )\n        }\n      })\n  }\n\n  _awaitUrl(actOrUrl: string | Object, name: string): Promise<any> {\n    return new Promise((resolve) => {\n      const url =\n        typeof actOrUrl === 'string' ? actOrUrl : actOrUrl.location.url\n      const ready = () => {\n        console.log('ready', url, locationToUrl(window.location))\n        return url === locationToUrl(window.location)\n      }\n      return tryChange(ready, resolve, name, this) // TODO: is the this supposed to be there, its one extra param over\n    })\n  }\n}\n\n// CHROME WORKAROUND:\n// chrome doesn't like rapid back to back history changes, so we test the first\n// change happened first, before executing the next\n\nlet tries = 0\nconst maxTries = 10\nconst queue = []\n\nconst tryChange = (ready, complete, name) => {\n  if (tries === 0) rapidChangeWorkaround(ready, complete, name)\n  else queue.push([ready, complete, name])\n}\n\nconst rapidChangeWorkaround = (ready, complete, name) => {\n  tries++\n\n  if (!ready() && tries < maxTries) {\n    console.log('tries', tries + 1, name)\n    setTimeout(() => rapidChangeWorkaround(ready, complete, name), 9)\n  } else {\n    if (process.env.NODE_ENV === 'test' && !ready()) {\n      throw new Error(\n        'BrowserHistory.rapidChangeWorkAround failed to be \"ready\"',\n      )\n    }\n\n    complete()\n    tries = 0\n\n    const [again, com, name] = queue.shift() || [] // try another if queue is full\n\n    if (again) {\n      rapidChangeWorkaround(again, com, name)\n    }\n  }\n}\n"],"file":"BrowserHistory.js"}